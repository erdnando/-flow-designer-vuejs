// ...existing code...

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount, watch } from 'vue';
import { ExternalComponentLoader } from '../services/ExternalComponentLoader';
import { MockComponentRegistry } from '../services/MockComponentRegistry';

// Props
const props = defineProps<{
  wizardStep: {
    componentData?: {
      customTypeId?: string;
      componentVersion?: string;
    };
  };
  zoomLevel?: number; // Nivel de zoom para el componente
}>();

// Emits
const emit = defineEmits(['next', 'previous', 'ready', 'error']);

// Variables reactivas
const loading = ref(true);
const error = ref<string | null>(null);
const componentInfo = ref<any>(null);
const componentInstance = ref<any>(null);
const outputData = ref<any>({}); // Almacenar datos de salida del componente
const containerHeight = ref<number>(600); // Altura calculada del contenedor
const showDummyView = ref(false); // Mostrar vista dummy si el microfrontend no est√° disponible

// Variables de sesi√≥n para simular
const sessionId = `sim-${Date.now()}`;
const flowContext = {
  sessionId,
  currentStep: props.wizardStep?.componentData?.customTypeId,
  simulationMode: true
};

// Funci√≥n para calcular la altura del contenedor
function calculateContainerHeight() {
  const container = document.querySelector('.external-component-container') as HTMLElement;
  if (container && container.parentElement) {
    const parentHeight = container.parentElement.clientHeight;
    const containerStyles = getComputedStyle(container);
    const marginTop = parseInt(containerStyles.marginTop) || 0;
    const marginBottom = parseInt(containerStyles.marginBottom) || 0;
    const borderTop = parseInt(containerStyles.borderTopWidth) || 0;
    const borderBottom = parseInt(containerStyles.borderBottomWidth) || 0;

    // Obtener el nivel de zoom actual
    const zoomLevel = props.zoomLevel || 1.0;
    // Ajustar el alto del contenedor para que el contenido escalado siempre ocupe el √°rea m√°xima
    const scaledHeight = (parentHeight - marginTop - marginBottom - borderTop - borderBottom - 5) / zoomLevel;
    containerHeight.value = Math.max(scaledHeight, 550);
    console.log('üîç Altura calculada (ajustada por zoom):', containerHeight.value, 'px (padre:', parentHeight, 'px, zoom:', zoomLevel, ')');

    // Aplicar la altura inmediatamente al contenedor
    if (container) {
      container.style.height = `${containerHeight.value}px`;
    }
  }
}

// Watch para cambios en el zoomLevel
watch(() => props.zoomLevel, (newZoomLevel) => {
  console.log('üîç ZoomLevel cambi√≥ a:', newZoomLevel);
  // Actualizar la variable CSS directamente en el elemento
  const mountPoint = document.getElementById('component-mount-point');
  if (mountPoint) {
    const zoomValue = String(newZoomLevel || 1.0);
    mountPoint.style.setProperty('--component-zoom', zoomValue);
    console.log('‚úÖ Variable CSS --component-zoom actualizada a:', zoomValue);
    console.log('üîç Transform actual del elemento:', getComputedStyle(mountPoint).transform);
  } else {
    console.warn('‚ö†Ô∏è No se encontr√≥ el elemento component-mount-point');
  }
  
  // Recalcular altura del contenedor cuando cambie el zoom
  setTimeout(() => {
    calculateContainerHeight();
  }, 50); // Peque√±o delay para que el transform se aplique completamente
}, { immediate: true });

// Funci√≥n para cargar el componente externo
async function loadExternalComponent() {
  if (!props.wizardStep?.componentData?.customTypeId) {
    error.value = 'ID de componente no especificado';
    loading.value = false;
    emit('error', 'ID de componente no especificado');
    return;
  }
  
  const customTypeId = props.wizardStep.componentData.customTypeId;
  const version = props.wizardStep.componentData.componentVersion || '1.0.0';
  
  try {
    console.log(`üîÑ Cargando componente externo: ${customTypeId} v${version}`);
    
    // Verificar todos los componentes disponibles en ambos registros
    console.log('Componentes disponibles en MockComponentRegistry:', 
                MockComponentRegistry.getAllComponents().map(c => c.id));
    console.log('Componentes registrados en ExternalComponentLoader:', 
                ExternalComponentLoader.getRegisteredComponentIds());
    console.log(`¬øEst√° registrado '${customTypeId}' en ExternalComponentLoader?:`,
                ExternalComponentLoader.isRegistered(customTypeId));
    
    // Obtener configuraci√≥n del componente
    const componentConfig = MockComponentRegistry.getComponent(customTypeId);
    if (!componentConfig) {
      // Mostrar dummy si el componente no existe
      showDummyView.value = true;
      loading.value = false;
      error.value = `El microfrontend '${customTypeId}' no est√° disponible.`;
      emit('error', error.value);
      return;
    }
    
    // Guardar info del componente
    componentInfo.value = {
      id: componentConfig.id,
      name: componentConfig.name,
      version: componentConfig.version,
      tagName: componentConfig.metadata.tagName
    };
    
    // Limpiar cualquier contenido previo
    const mountPoint = document.getElementById('component-mount-point');
    if (!mountPoint) {
      console.error('‚ùå Punto de montaje component-mount-point no encontrado en el DOM');
      throw new Error('Punto de montaje no disponible para el componente');
    }
    
    // Limpiar el punto de montaje antes de a√±adir un nuevo componente
    mountPoint.innerHTML = '';
    console.log('‚úÖ Punto de montaje encontrado y limpiado');
    
    // Cargar el componente web sin depender de refs
    await ExternalComponentLoader.loadComponent(customTypeId, version)
      .catch(async (err) => {
        console.warn(`Error al cargar componente con loader, intentando registro manual:`, err);
        // Registrar si no est√° registrado
        if (!ExternalComponentLoader.isRegistered(customTypeId)) {
          ExternalComponentLoader.registerComponent(componentConfig);
          return ExternalComponentLoader.loadComponent(customTypeId, version);
        }
        throw err;
      })
      .catch(async (err) => {
        console.warn(`Error despu√©s del registro manual, cargando script directamente:`, err);
        // Intentar cargar el script directamente como √∫ltimo recurso
        return new Promise<void>((resolve, reject) => {
          const script = document.createElement('script');
          script.src = componentConfig.cdnUrl;
          script.async = true;
          script.onload = () => {
            console.log(`‚úÖ Script cargado manualmente: ${componentConfig.cdnUrl}`);
            resolve();
          };
          script.onerror = (e) => reject(new Error(`Error al cargar script: ${e}`));
          document.head.appendChild(script);
        });
      });
      
    // Montar el componente usando el DOM API directamente
    console.log(`üîÑ Montando componente: ${componentConfig.metadata.tagName}`);
    
    // Verificar que el elemento custom est√© definido
    const customElementName = componentConfig.metadata.tagName;
    console.log(`üîç Verificando custom element: ${customElementName}`);
    console.log(`üîç customElements.get('${customElementName}'):`, customElements.get(customElementName));
    console.log(`üîç Lista de todos los custom elements definidos:`, 
                Object.getOwnPropertyNames(window).filter(name => name.includes('Element')));
    
    if (!customElements.get(customElementName)) {
      console.warn(`‚ö†Ô∏è Custom element '${customElementName}' no est√° registrado en customElements`);
      // Esperar un poco y reintentar
      await new Promise(resolve => setTimeout(resolve, 500));
      console.log(`üîç Segundo intento - customElements.get('${customElementName}'):`, customElements.get(customElementName));
      if (!customElements.get(customElementName)) {
        // Mostrar dummy si el custom element no est√° disponible
        showDummyView.value = true;
        loading.value = false;
        error.value = `El microfrontend '${customElementName}' no est√° disponible para este paso.`;
        emit('error', error.value);
        return;
      }
    }
    
    console.log(`‚úÖ Custom element '${customElementName}' est√° registrado`);
    
    // Crear elemento con manejo de errores
    let element;
    try {
      console.log(`üîÑ Intentando crear elemento: ${customElementName}`);
      element = document.createElement(customElementName);
      console.log(`‚úÖ Elemento '${customElementName}' creado exitosamente`);
      console.log(`üìä Tipo de elemento creado:`, typeof element, element.constructor.name);
    } catch (createError: any) {
      console.error(`‚ùå Error al crear elemento '${customElementName}':`, createError);
      throw new Error(`Error al crear el elemento: ${createError.message || createError}`);
    }
    
    componentInstance.value = element;
    
    // Configurar atributos de entrada
    element.setAttribute('session-id', sessionId);
    element.setAttribute('user-id', `user-${sessionId.split('-')[1]}`); // Generar user-id basado en session
    
    // Configurar objeto config
    const config = {
      theme: 'dark',
      showFooter: true,
      simulationMode: false, // Cambiar a false para que se vea igual que el acceso directo
      zoomLevel: props.zoomLevel || 1.0,
      // Agregar informaci√≥n de dimensiones para que el componente se ajuste
      containerDimensions: {
        width: '100%',
        height: '100%',
        minHeight: '600px', // Aumentar altura m√≠nima
        maxWidth: '100%',   // NUEVO: Limitar ancho m√°ximo
        maxHeight: '100%',  // NUEVO: Limitar altura m√°xima
        forceFullHeight: true,
        containment: true,  // NUEVO: Indicar al componente que debe contenerse
        isModal: true,      // NUEVO: Indicar que est√° dentro de un modal
        parentContainer: 'wizard-modal', // NUEVO: Identificar el contenedor padre
        // NUEVO: Informaci√≥n espec√≠fica sobre el contexto de altura
        heightContext: {
          useContainerHeight: true,  // NO usar 100vh
          respectParentDimensions: true,
          availableHeight: `${containerHeight.value}px`,
          viewportUsage: 'container-relative' // No viewport-relative
        }
      }
    };
    element.setAttribute('config', JSON.stringify(config));
    
    // HACK ESPEC√çFICO para ine-validation-component: forzar altura via CSS inline
    if (customElementName === 'ine-validation-component') {
      // SOLUCI√ìN RADICAL: Calcular altura exacta del contenedor disponible
      const availableHeight = containerHeight.value - 20; // 20px de margen de seguridad
      
      element.style.height = `${availableHeight}px`; // Altura espec√≠fica en pixels, no porcentaje
      element.style.minHeight = `${availableHeight}px`;
      element.style.maxHeight = `${availableHeight}px`; // Altura exacta, sin flexibilidad
      element.style.display = 'flex';
      element.style.flexDirection = 'column';
      // NUEVO: Contenci√≥n adicional m√°s agresiva
      element.style.position = 'relative';
      element.style.overflow = 'hidden';
      element.style.maxWidth = '100%';
      element.style.width = '100%';
      element.style.contain = 'strict';
      element.style.clipPath = 'inset(0)'; // Forzar recorte visual
      
      // NUEVO: Forzar que NO use viewport height con valores espec√≠ficos
      element.style.setProperty('--viewport-height', `${availableHeight}px`);
      element.style.setProperty('--container-height', `${availableHeight}px`);
      element.style.setProperty('--max-height', `${availableHeight}px`);
      
      // NUEVO: Interceptar todas las variables CSS comunes que podr√≠an usar 100vh
      element.style.setProperty('--vh', `${availableHeight/100}px`); // 1vh = altura/100
      element.style.setProperty('--full-height', `${availableHeight}px`);
      element.style.setProperty('--window-height', `${availableHeight}px`);
      
      console.log(`üîß APLICADO: Estilos espec√≠ficos para ine-validation-component con altura FIJA: ${availableHeight}px`);
    }
    
    // Configurar flow-context expandido
    const expandedFlowContext = {
      ...flowContext,
      currentStep: 1,
      totalSteps: 4,
      componentId: props.wizardStep?.componentData?.customTypeId,
      componentVersion: props.wizardStep?.componentData?.componentVersion || '1.0.0'
    };
    element.setAttribute('flow-context', JSON.stringify(expandedFlowContext));
    
    console.log('üîß Atributos configurados:');
    console.log('  - session-id:', sessionId);
    console.log('  - user-id:', `user-${sessionId.split('-')[1]}`);
    console.log('  - config:', JSON.stringify(config, null, 2));
    console.log('  - flow-context:', JSON.stringify(expandedFlowContext, null, 2));
    
    // DEBUG: Log antes de agregar listeners
    console.log('[DEBUG] Agregando event listeners al custom element', element);
    element.addEventListener('component-ready', handleComponentReady);
    element.addEventListener('output-data', handleOutputData);
    element.addEventListener('next-step', handleNextStep);
    element.addEventListener('request-navigation', handleNavigation);
    element.addEventListener('node-error', handleComponentError);
    // DEBUG: Log despu√©s de agregar listeners
    console.log('[DEBUG] Event listeners agregados. Montando el custom element...');
// Handler para evento next-step (emitido por microfrontends)
function handleNextStep(event: any) {
  console.log('‚û°Ô∏è Evento next-step recibido:', event.detail);
  if (event) {
    console.log('üü¢ [DEBUG] handleNextStep: Event recibido correctamente.');
    if (event.detail) {
      console.log('üü¢ [DEBUG] handleNextStep: event.detail =', event.detail);
    } else {
      console.warn('üü° [DEBUG] handleNextStep: event.detail est√° vac√≠o');
    }
  } else {
    console.error('üî¥ [DEBUG] handleNextStep: Event es undefined/null');
  }
  // Reutilizar la l√≥gica de handleOutputData para estructurar y emitir los datos
  handleOutputData(event);
}
    console.log(`üéß Event listeners configurados para el componente`);
    
    // Obtener punto de montaje actualizado
    const finalMountPoint = document.getElementById('component-mount-point');
    if (!finalMountPoint) {
      throw new Error('Punto de montaje no disponible despu√©s de la preparaci√≥n');
    }
    
    // Montar componente
    finalMountPoint.appendChild(element);
    console.log(`[DEBUG] Custom element montado en el DOM`, element);
    console.log(`‚úÖ Componente montado exitosamente en #component-mount-point`);
    
    // SOLUCI√ìN RADICAL: Crear un wrapper de contenci√≥n para TODOS los componentes
    const wrapperDiv = document.createElement('div');
    wrapperDiv.style.cssText = `
      width: 100%;
      height: 100%;
      min-height: 600px;
      max-height: 100%;
      overflow: hidden;
      position: relative;
      contain: layout style size;
      clip-path: inset(0);
      isolation: isolate;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      
    `;
    
    // NUEVA JAULA DE CONTENCI√ìN INTERIOR para evitar desbordamiento inferior
    const innerContainmentDiv = document.createElement('div');
    innerContainmentDiv.style.cssText = `
      width: 100%;
      height: 100%;
      max-height: 100%;
      min-height: 100%;
      max-width: 100%;
      overflow: hidden;
      position: relative;
      contain: strict;
      clip-path: inset(0);
      isolation: isolate;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
      overflow-y: auto !important;
    `;
    
    // Crear doble contenci√≥n: wrapper exterior + jaula interior
    innerContainmentDiv.appendChild(element);
    wrapperDiv.appendChild(innerContainmentDiv);
    finalMountPoint.appendChild(wrapperDiv);
    
    console.log(`üîí DOBLE WRAPPER DE CONTENCI√ìN aplicado para control superior e inferior`);
    
    // INTERCEPTOR GLOBAL: Sobrescribir cualquier CSS que use 100vh
    const originalStyle = window.getComputedStyle;
    const availableHeight = containerHeight.value - 20;
    
    // Interceptar getComputedStyle para elementos dentro del componente
    Object.defineProperty(window, 'getComputedStyle', {
      value: function(element: Element, pseudoElement?: string | null) {
        const styles = originalStyle.call(this, element, pseudoElement);
        
        // Si el elemento est√° dentro de nuestro microfrontend
        if (finalMountPoint.contains(element)) {
          const proxy = new Proxy(styles, {
            get(target, property) {
              const value = target[property as keyof CSSStyleDeclaration];
              
              // Interceptar valores de altura que usen 100vh
              if ((property === 'height' || property === 'minHeight' || property === 'maxHeight') && 
                  typeof value === 'string' && value === '100vh') {
                console.log(`üö® INTERCEPTADO: ${property} = 100vh cambiado a ${availableHeight}px`);
                return `${availableHeight}px`;
              }
              
              return value;
            }
          });
          return proxy as CSSStyleDeclaration;
        }
        
        return styles;
      },
      configurable: true
    });
    
    console.log(`üîí INTERCEPTOR CSS aplicado para sobrescribir 100vh con ${availableHeight}px`);
    
    // HACK ADICIONAL: Para ine-validation-component, aplicar dimensiones despu√©s de montar
    if (customElementName === 'ine-validation-component') {
      setTimeout(() => {
        const mountedElement = document.querySelector('ine-validation-component') as HTMLElement;
        if (mountedElement) {
          // Forzar dimensiones estrictas con altura exacta
          const exactElementHeight = containerHeight.value - 60; // M√°s margen de seguridad
          mountedElement.style.height = `${exactElementHeight}px`;
          mountedElement.style.maxHeight = `${exactElementHeight}px`;
          mountedElement.style.minHeight = `${exactElementHeight}px`;
          mountedElement.style.display = 'flex';
          mountedElement.style.flexDirection = 'column';
          // Contenci√≥n estricta
          mountedElement.style.position = 'relative';
          mountedElement.style.overflow = 'hidden';
          mountedElement.style.maxWidth = '100%';
          mountedElement.style.contain = 'strict';
          mountedElement.style.clipPath = 'inset(0)';
          
          console.log(`üîß APLICADO: Altura exacta de ${exactElementHeight}px al elemento montado`);
          
          // NUEVO: Interceptar y corregir cualquier elemento que se desborde
          const observer = new MutationObserver(() => {
            const allChildren = mountedElement.querySelectorAll('*');
            allChildren.forEach((child: Element) => {
              const htmlChild = child as HTMLElement;
              const rect = htmlChild.getBoundingClientRect();
              const parentRect = mountedElement.getBoundingClientRect();
              
              // Si el elemento se extiende m√°s all√° del contenedor padre
              if (rect.bottom > parentRect.bottom + 5) { // 5px de tolerancia
                htmlChild.style.maxHeight = '100%';
                htmlChild.style.overflow = 'hidden';
                htmlChild.style.position = 'relative';
                console.log('üö® CORREGIDO: Elemento desbordado hacia abajo:', htmlChild.tagName);
              }
              
              // NUEVO: Detectar y corregir uso de 100vh
              const computedStyle = getComputedStyle(htmlChild);
              if (computedStyle.height === '100vh' || 
                  computedStyle.minHeight === '100vh' ||
                  computedStyle.maxHeight === '100vh') {
                htmlChild.style.height = '100%';
                htmlChild.style.minHeight = '100%';
                htmlChild.style.maxHeight = '100%';
                console.log('üö® CORREGIDO: Elemento usaba 100vh, cambiado a 100%:', htmlChild.tagName, htmlChild.className);
              }
              
              // Tambi√©n verificar estilos inline
              if (htmlChild.style.height === '100vh' || 
                  htmlChild.style.minHeight === '100vh') {
                htmlChild.style.height = '100%';
                htmlChild.style.minHeight = '100%';
                htmlChild.style.maxHeight = '100%';
                console.log('üö® CORREGIDO: Estilo inline 100vh detectado y corregido:', htmlChild.tagName);
              }
            });
          });
          
          observer.observe(mountedElement, {
            childList: true,
            subtree: true,
            attributes: true,
            attributeFilter: ['style', 'class']
          });
          
          // Tambi√©n intentar forzar estilos en el contenido interno si es posible
          const shadowRoot = mountedElement.shadowRoot;
          if (shadowRoot) {
            const allDivs = shadowRoot.querySelectorAll('div');
            allDivs.forEach((div: HTMLElement) => {
              div.style.height = '100%';
              div.style.maxHeight = '100%';
              div.style.minHeight = 'inherit';
              div.style.position = 'relative';
              div.style.maxWidth = '100%';
              div.style.overflow = 'hidden';
              div.style.boxSizing = 'border-box';
              
              // NUEVO: Sobrescribir cualquier uso de 100vh en shadow DOM
              const computedStyle = getComputedStyle(div);
              if (computedStyle.height === '100vh' || computedStyle.minHeight === '100vh') {
                div.style.height = '100%';
                div.style.minHeight = '100%';
                console.log('üö® CORREGIDO: Elemento en shadow DOM usaba 100vh, cambiado a 100%');
              }
            });
            
            // NUEVO: Inyectar CSS personalizado en el shadow DOM para sobrescribir 100vh
            const styleElement = document.createElement('style');
            styleElement.textContent = `
              * {
                height: var(--container-height, 100%) !important;
                max-height: 100% !important;
              }
              *[style*="100vh"] {
                height: 100% !important;
                min-height: 100% !important;
              }
              div, main, section, article {
                max-height: 100% !important;
              }
            `;
            shadowRoot.appendChild(styleElement);
            
            console.log('üîß FORZADO: Estilos internos en shadow DOM con l√≠mites estrictos y CSS anti-100vh');
          }
        }
      }, 500); // Esperar medio segundo para que el componente se inicialice completamente
    }
    
    loading.value = false;
  } catch (err: any) {
    console.error('Error al cargar componente externo:', err);
    error.value = err?.message || 'Error al cargar componente';
    loading.value = false;
    // Mostrar dummy si ocurre cualquier error de carga
    showDummyView.value = true;
    emit('error', error.value);
  }
}

// Handlers de eventos
function handleComponentReady(event: Event) {
  console.log('üéâ Componente externo listo:', event);
  console.log('üìã Detalles del evento component-ready:', (event as CustomEvent).detail);
  emit('ready', event);
}

function handleOutputData(event: any) {
  console.log('üì§ Datos de salida del componente:', event.detail);
  console.log('üü¢ [DEBUG] handleOutputData: Iniciado con event:', event);
  if (event && event.detail) {
    console.log('üü¢ [DEBUG] handleOutputData: event.detail =', event.detail);
  } else {
    console.warn('üü° [DEBUG] handleOutputData: event o event.detail est√° vac√≠o');
  }
  
  // Almacenar datos de salida
  outputData.value = { ...outputData.value, ...event.detail };
  
  // Extraer par√°metros espec√≠ficos si est√°n presentes
  const { horaInicio, horaFin, ...otherData } = event.detail || {};
  
  if (horaInicio) {
    console.log('‚è∞ Hora de inicio capturada:', horaInicio);
  }
  
  if (horaFin) {
    console.log('‚è∞ Hora de fin capturada:', horaFin);
  }
  
  if (Object.keys(otherData).length > 0) {
    console.log('üìã Otros datos capturados:', otherData);
  }
  
  // Crear objeto estructurado con todos los datos
  const structuredData = {
    sessionId,
    componentId: props.wizardStep?.componentData?.customTypeId,
    timestamp: new Date().toISOString(),
    outputParameters: {
      horaInicio,
      horaFin,
      ...otherData
    },
    allData: event.detail
  };
  
  console.log('üîÑ Avanzando al siguiente paso con datos estructurados:', structuredData);
  console.log('üü¢ [DEBUG] handleOutputData: Emitiendo "next" con structuredData:', structuredData);
  emit('next', structuredData);
}

function handleNavigation(event: any) {
  console.log('üß≠ Solicitud de navegaci√≥n:', event.detail);
  if (event.detail?.direction === 'previous') {
    console.log('‚¨ÖÔ∏è Navegando hacia atr√°s');
    emit('previous');
  }
}

function handleComponentError(event: any) {
  console.error('üö® Error en componente externo:', event.detail);
  error.value = event.detail?.message || 'Error en el componente';
  emit('error', error.value);
}

// Funci√≥n para obtener los datos de salida capturados
function getOutputData() {
  return outputData.value;
}

// Funci√≥n para obtener par√°metros espec√≠ficos
function getOutputParameter(key: string) {
  return outputData.value[key];
}

// Funci√≥n para limpiar los datos de salida
function clearOutputData() {
  outputData.value = {};
}

// Exponer funciones para uso externo
defineExpose({
  getOutputData,
  getOutputParameter,
  clearOutputData,
  componentInstance
});

// Lifecycle hooks
onMounted(() => {
  console.log('üîÑ ExternalComponentView montado, inicializando carga del componente');
  
  // Calcular altura inicial
  setTimeout(() => {
    calculateContainerHeight();
  }, 50);
  
  // Escuchar cambios de tama√±o de ventana
  window.addEventListener('resize', calculateContainerHeight);
  
  // Observador para cambios en el tama√±o del elemento padre
  const resizeObserver = new ResizeObserver(() => {
    calculateContainerHeight();
  });
  
  // Observar el elemento padre cuando est√© disponible
  const checkParent = () => {
    const container = document.querySelector('.external-component-container') as HTMLElement;
    if (container?.parentElement) {
      resizeObserver.observe(container.parentElement);
      console.log('üîç ResizeObserver configurado en elemento padre');
      
      // NUEVO: Observador de mutaciones para detectar si el componente intenta escaparse
      const mutationObserver = new MutationObserver(() => {
        const mountedComponents = container.querySelectorAll('ine-validation-component, landing-web-component, sms-verification-component');
        mountedComponents.forEach((component) => {
          const htmlComponent = component as HTMLElement;
          if (htmlComponent.style.position === 'fixed' || htmlComponent.style.position === 'absolute') {
            htmlComponent.style.position = 'relative';
            console.log('üö® CORREGIDO: Componente intent√≥ escapar usando position fixed/absolute');
          }
        });
      });
      
      mutationObserver.observe(container, {
        childList: true,
        subtree: true,
        attributes: true,
        attributeFilter: ['style']
      });
    } else {
      setTimeout(checkParent, 100);
    }
  };
  checkParent();
  
  setTimeout(() => {
    // Ejecutar con un peque√±o delay para asegurar que el DOM est√° completamente renderizado
    loadExternalComponent();
  }, 100); // Un peque√±o delay para asegurar que el DOM est√° listo
});

onBeforeUnmount(() => {
  // Limpiar event listener de resize
  window.removeEventListener('resize', calculateContainerHeight);
  
  // Desconectar el ResizeObserver
  const container = document.querySelector('.external-component-container') as HTMLElement;
  if (container?.parentElement) {
    // El ResizeObserver se desconecta autom√°ticamente cuando el componente se desmonta
    console.log('üîç Limpiando ResizeObserver');
  }
  
  // Limpiar el componente y los eventos
  if (componentInstance.value) {
    componentInstance.value.removeEventListener('component-ready', handleComponentReady);
    componentInstance.value.removeEventListener('output-data', handleOutputData);
    componentInstance.value.removeEventListener('request-navigation', handleNavigation);
    componentInstance.value.removeEventListener('node-error', handleComponentError);
    // Limpiar del DOM si est√° montado, solo si tiene parentNode
    if (componentInstance.value.parentNode) {
      componentInstance.value.parentNode.removeChild(componentInstance.value);
    }
  }
});

// Observar cambios en el paso del wizard
watch(() => props.wizardStep?.componentData, () => {
  if (componentInstance.value) {
    // Si cambia el paso y ya tenemos un componente instanciado, actualizarlo
    componentInstance.value.setAttribute('flow-context', JSON.stringify({
      ...flowContext,
      currentStep: props.wizardStep?.componentData?.customTypeId
    }));
  }
}, { deep: true });
</script>

<template>
  <div class="external-component-container" :style="{ height: `${containerHeight}px` }">
    <!-- Dummy/Fallback View -->
    <div v-if="showDummyView" class="dummy-fallback-container">
      <div class="dummy-icon">üö´</div>
      <h3>Microfrontend no disponible</h3>
      <p>El componente externo requerido para este paso no est√° disponible en este momento.<br>
        Por favor, intente m√°s tarde o contacte a soporte si el problema persiste.</p>
      <button
        id="dummy-support-btn"
        class="dummy-support-btn"
        @click.prevent
        style="background:#ff1744 !important;color:#fff !important;border:none !important;box-shadow:0 2px 8px 0 rgba(0,0,0,0.18) !important;"
      >Reportar a soporte</button>
    </div>

    <!-- Siempre tener el punto de montaje disponible pero oculto seg√∫n el estado -->
    <div 
      id="component-mount-point" 
      class="component-mount-point" 
      :style="{ 
        display: !loading && !error && !showDummyView ? 'flex' : 'none',
        '--component-zoom': props.zoomLevel || 1.0
      }"
    >
      <!-- El componente web se montar√° aqu√≠ -->
    </div>
    
    <div v-if="loading && !showDummyView" class="loading-container">
      <div class="loading-spinner"></div>
      <p>Cargando componente externo...</p>
    </div>
    
    <div v-if="error && !showDummyView" class="error-container">
      <h3>‚ö†Ô∏è Error al cargar el componente</h3>
      <p>{{ error }}</p>
    </div>
    
    <div class="component-info" v-if="componentInfo && !showDummyView">
      <span class="component-tag">{{ componentInfo.id }} v{{ componentInfo.version }}</span>
    </div>
  </div>
</template>
.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  border-top: 4px solid #4caf50;
  animation: spin 1s linear infinite;
  margin-bottom: 16px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.error-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  background-color: rgba(244, 67, 54, 0.1);
  color: #f44336;
  padding: 20px;
}

/* Aplicar zoom din√°mico al contenido del componente externo */
.component-mount-point {
  flex: 1;
  min-height: 0; /* Permitir que se comprima */
  overflow: hidden; /* Sin scroll en el punto de montaje */
  width: 100%;
  height: 100%;
  position: relative;
  /* Aplicar zoom solo al contenido del componente */
  transform: scale(var(--component-zoom, 1));
  transform-origin: center center;
  transition: transform 0.2s ease-in-out;
  /* Centrar el contenido para que se vea completo */
  display: flex;
  justify-content: center;
  align-items: stretch; /* Cambiar a stretch para que use toda la altura */
  flex-direction: column;
  /* Remover padding para maximizar espacio disponible */
  /* NUEVO: Contenci√≥n estricta del punto de montaje */
  contain: layout style; /* Contener layout y estilos */
  isolation: isolate; /* Aislar el contexto de apilamiento */
}

/* Dar dimensiones apropiadas al componente web */
.component-mount-point > * {
  width: 100% !important;   /* Usar todo el ancho disponible */
  height: 100% !important;  /* Usar toda la altura disponible */
  min-width: 350px;  /* Ancho m√≠nimo para asegurar legibilidad */
  min-height: 450px; /* Altura m√≠nima para asegurar contenido visible */
  max-width: 100% !important; /* NUEVO: Limitar el ancho m√°ximo */
  max-height: 100% !important; /* NUEVO: Limitar la altura m√°xima */
  flex-shrink: 0; /* No permitir que se encoja */
  box-sizing: border-box; /* Incluir padding y border en las dimensiones */
  /* Forzar que el contenido interno tambi√©n use toda la altura */
  display: flex !important;
  flex-direction: column !important;
  /* NUEVO: Evitar que el componente escape de su contenedor */
  position: relative !important; /* Forzar posici√≥n relativa */
  overflow: hidden !important; /* Evitar scroll y desbordamiento */
  contain: layout style size !important; /* Contenci√≥n total */
}

/* Asegurar que el contenido interno del web component tambi√©n se estire */
.component-mount-point > * > *,
.component-mount-point > * > * > * {
  flex: 1 !important;
  height: 100% !important;
  min-height: inherit !important;
}

/* Estilos espec√≠ficos para web components comunes */
.component-mount-point landing-web-component,
.component-mount-point ine-validation-component,
.component-mount-point sms-verification-component {
  height: 100% !important;
  min-height: 100% !important;
  display: flex !important;
  flex-direction: column !important;
}

/* NUEVO: Interceptar y sobrescribir cualquier uso de 100vh en el microfrontend */
.component-mount-point *[style*="100vh"],
.component-mount-point *[style*="height: 100vh"],
.component-mount-point *[style*="min-height: 100vh"] {
  height: 100% !important;
  min-height: 100% !important;
  max-height: 100% !important;
}

/* Forzar que elementos comunes NO usen 100vh */
.component-mount-point div,
.component-mount-point main,
.component-mount-point section,
.component-mount-point article,
.component-mount-point .container,
.component-mount-point .wrapper {
  max-height: 100% !important;
}

/* Estilos s√∫per espec√≠ficos para ine-validation-component que parece tener problemas */
.component-mount-point ine-validation-component {
  height: 100% !important; /* Cambiar de 100vh a 100% para respetar contenedor */
  min-height: 600px !important;
  max-height: 100% !important; /* Limitar altura m√°xima */
  width: 100% !important;
  max-width: 100% !important;
  position: relative !important;
  overflow: hidden !important;
  transform: none !important; /* Evitar transforms que puedan causar escape */
  contain: strict !important; /* Contenci√≥n m√°s estricta */
  clip-path: inset(0) !important; /* Forzar recorte visual */
  box-sizing: border-box !important;
}

/* NUEVA REGLA: Forzar altura fija cuando el componente intenta usar 100vh */
.component-mount-point ine-validation-component[style*="100vh"],
.component-mount-point ine-validation-component * [style*="100vh"] {
  height: calc(75vh - 100px) !important; /* Altura espec√≠fica basada en el contenedor real */
  min-height: calc(75vh - 100px) !important;
  max-height: calc(75vh - 100px) !important;
}

/* SUPER HACK: Crear un contenedor wrapper para contener completamente el componente */
.component-mount-point {
  position: relative !important;
  overflow: hidden !important;
  clip-path: inset(0) !important; /* Forzar recorte visual */
  max-height: 100% !important; /* NUEVO: Evitar desbordamiento inferior */
  contain: strict !important; /* Contenci√≥n m√°s estricta */
}

/* NUEVO: Evitar que cualquier componente web escape de su contenedor */
.component-mount-point > *,
.component-mount-point > * *,
.component-mount-point > * * * {
  position: relative !important; /* Evitar position fixed/absolute que escape */
  z-index: auto !important; /* Evitar z-index extremos */
  transform: none !important; /* Evitar transforms que escapen */
}

/* NUEVO: Contener elementos que intenten usar posicionamiento absoluto */
.component-mount-point > * [style*="position: fixed"],
.component-mount-point > * [style*="position: absolute"] {
  position: relative !important;
  top: auto !important;
  left: auto !important;
  right: auto !important;
  bottom: auto !important;
}

/* Forzar altura en elementos internos del ine-validation-component */
.component-mount-point ine-validation-component * {
  box-sizing: border-box !important;
}

.component-mount-point ine-validation-component > div,
.component-mount-point ine-validation-component .container,
.component-mount-point ine-validation-component .wrapper,
.component-mount-point ine-validation-component .main,
.component-mount-point ine-validation-component .content,
.component-mount-point ine-validation-component .app,
.component-mount-point ine-validation-component .component-root {
  height: 100% !important;
  min-height: 100% !important;
  flex: 1 !important;
}

/* Forzar que cualquier contenedor padre dentro del shadow DOM tambi√©n use toda la altura */
.component-mount-point ine-validation-component::shadow-root,
.component-mount-point ine-validation-component::shadow {
  height: 100% !important;
  min-height: 100% !important;
}

/* Forzar altura completa en elementos internos comunes */
.component-mount-point [class*="container"],
.component-mount-point [class*="wrapper"],
.component-mount-point [class*="main"],
.component-mount-point [class*="content"] {
  height: 100% !important;
  min-height: 100% !important;
  flex: 1 !important;
}

/* Estilos globales para forzar altura completa en toda la cadena de contenedores */
.wizard-modal,
.wizard-main-content,
.wizard-content,
.wizard-step,
.step-content,
.component-container {
  min-height: 0 !important;
  height: auto !important;
  flex: 1 !important;
}

.component-info {
  position: absolute;
  top: 8px;
  right: 8px;
  z-index: 10;
  background: rgba(0, 0, 0, 0.8);
  border-radius: 4px;
}

.component-tag {
  background-color: #333;
  color: #fff;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 11px;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

/* Responsive para pantallas peque√±as  height: 100%;*/
@media (max-width: 900px) {
  .external-component-container {
    /* height ser√° calculada din√°micamente tambi√©n en m√≥viles */
    min-height: 300px !important;
  }
  
  .component-tag {
    font-size: 10px;
    padding: 2px 6px;
  }
}
  /* --- Dummy/Fallback styles --- */
  .dummy-fallback-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    height: 100%;
    width: 100%;
    background: rgba(30,30,30,0.95);
    color: #fff;
    border: 2px dashed #f44336;
    border-radius: 10px;
    padding: 40px 20px;
    box-sizing: border-box;
    z-index: 20;
    position: absolute;
    top: 0;
    left: 0;
  }
  .dummy-icon {
    font-size: 3rem;
    margin-bottom: 16px;
  }
  #dummy-support-btn {
    margin-top: 24px;
    padding: 12px 28px;
    background: #ff1744 !important;
    color: #fff !important;
    border: none !important;
    border-radius: 8px !important;
    font-size: 1.08rem !important;
    font-weight: 600 !important;
    cursor: pointer !important;
    box-shadow: 0 2px 8px 0 rgba(0,0,0,0.18) !important;
    transition: background 0.2s, box-shadow 0.2s, color 0.2s !important;
    outline: none !important;
    letter-spacing: 0.5px !important;
    opacity: 1 !important;
    filter: none !important;
    text-shadow: none !important;
    box-sizing: border-box !important;
    appearance: none !important;
    background-image: none !important;
    z-index: 30 !important;
  }
  #dummy-support-btn:hover, #dummy-support-btn:focus {
    background: #ff4569 !important;
    color: #fff !important;
    box-shadow: 0 4px 16px 0 rgba(255,23,68,0.18) !important;
  }
// ...existing code...
