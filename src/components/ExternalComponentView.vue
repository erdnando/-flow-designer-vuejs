<template>
  <div class="external-component-container" :style="{ height: `${containerHeight}px` }">
    <!-- Siempre tener el punto de montaje disponible pero oculto seg√∫n el estado -->
    <div 
      id="component-mount-point" 
      class="component-mount-point" 
      :style="{ 
        display: !loading && !error ? 'flex' : 'none',
        '--component-zoom': props.zoomLevel || 1.0
      }"
    >
      <!-- El componente web se montar√° aqu√≠ -->
    </div>
    
    <div v-if="loading" class="loading-container">
      <div class="loading-spinner"></div>
      <p>Cargando componente externo...</p>
    </div>
    
    <div v-if="error" class="error-container">
      <h3>‚ö†Ô∏è Error al cargar el componente</h3>
      <p>{{ error }}</p>
    </div>
    
    <div class="component-info" v-if="componentInfo">
      <span class="component-tag">{{ componentInfo.id }} v{{ componentInfo.version }}</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, onMounted, onBeforeUnmount, watch } from 'vue';
import { ExternalComponentLoader } from '../services/ExternalComponentLoader';
import { MockComponentRegistry } from '../services/MockComponentRegistry';

// Props
const props = defineProps<{
  wizardStep: {
    componentData?: {
      customTypeId?: string;
      componentVersion?: string;
    };
  };
  zoomLevel?: number; // Nivel de zoom para el componente
}>();

// Emits
const emit = defineEmits(['next', 'previous', 'ready', 'error']);

// Variables reactivas
const loading = ref(true);
const error = ref<string | null>(null);
const componentInfo = ref<any>(null);
const componentInstance = ref<any>(null);
const outputData = ref<any>({}); // Almacenar datos de salida del componente
const containerHeight = ref<number>(600); // Altura calculada del contenedor

// Variables de sesi√≥n para simular
const sessionId = `sim-${Date.now()}`;
const flowContext = {
  sessionId,
  currentStep: props.wizardStep?.componentData?.customTypeId,
  simulationMode: true
};

// Funci√≥n para calcular la altura del contenedor
function calculateContainerHeight() {
  const container = document.querySelector('.external-component-container') as HTMLElement;
  if (container && container.parentElement) {
    const parentHeight = container.parentElement.clientHeight;
    const containerStyles = getComputedStyle(container);
    const marginTop = parseInt(containerStyles.marginTop) || 0;
    const marginBottom = parseInt(containerStyles.marginBottom) || 0;
    const borderTop = parseInt(containerStyles.borderTopWidth) || 0;
    const borderBottom = parseInt(containerStyles.borderBottomWidth) || 0;
    
    const calculatedHeight = parentHeight - marginTop - marginBottom - borderTop - borderBottom;
    containerHeight.value = Math.max(calculatedHeight + 200, 400); // Agregar 200px extra y m√≠nimo 400px
    console.log('üîç Altura calculada:', containerHeight.value, 'px (padre:', parentHeight, 'px, +200px extra)');
  }
}

// Watch para cambios en el zoomLevel
watch(() => props.zoomLevel, (newZoomLevel) => {
  console.log('üîç ZoomLevel cambi√≥ a:', newZoomLevel);
  // Actualizar la variable CSS directamente en el elemento
  const mountPoint = document.getElementById('component-mount-point');
  if (mountPoint) {
    const zoomValue = String(newZoomLevel || 1.0);
    mountPoint.style.setProperty('--component-zoom', zoomValue);
    console.log('‚úÖ Variable CSS --component-zoom actualizada a:', zoomValue);
    console.log('üîç Transform actual del elemento:', getComputedStyle(mountPoint).transform);
  } else {
    console.warn('‚ö†Ô∏è No se encontr√≥ el elemento component-mount-point');
  }
  
  // Recalcular altura del contenedor cuando cambie el zoom
  setTimeout(() => {
    calculateContainerHeight();
  }, 50); // Peque√±o delay para que el transform se aplique completamente
}, { immediate: true });

// Funci√≥n para cargar el componente externo
async function loadExternalComponent() {
  if (!props.wizardStep?.componentData?.customTypeId) {
    error.value = 'ID de componente no especificado';
    loading.value = false;
    emit('error', 'ID de componente no especificado');
    return;
  }
  
  const customTypeId = props.wizardStep.componentData.customTypeId;
  const version = props.wizardStep.componentData.componentVersion || '1.0.0';
  
  try {
    console.log(`üîÑ Cargando componente externo: ${customTypeId} v${version}`);
    
    // Verificar todos los componentes disponibles en ambos registros
    console.log('Componentes disponibles en MockComponentRegistry:', 
                MockComponentRegistry.getAllComponents().map(c => c.id));
    console.log('Componentes registrados en ExternalComponentLoader:', 
                ExternalComponentLoader.getRegisteredComponentIds());
    console.log(`¬øEst√° registrado '${customTypeId}' en ExternalComponentLoader?:`,
                ExternalComponentLoader.isRegistered(customTypeId));
    
    // Obtener configuraci√≥n del componente
    const componentConfig = MockComponentRegistry.getComponent(customTypeId);
    if (!componentConfig) {
      throw new Error(`Componente no encontrado en el registro: ${customTypeId}`);
    }
    
    // Guardar info del componente
    componentInfo.value = {
      id: componentConfig.id,
      name: componentConfig.name,
      version: componentConfig.version,
      tagName: componentConfig.metadata.tagName
    };
    
    // Limpiar cualquier contenido previo
    const mountPoint = document.getElementById('component-mount-point');
    if (!mountPoint) {
      console.error('‚ùå Punto de montaje component-mount-point no encontrado en el DOM');
      throw new Error('Punto de montaje no disponible para el componente');
    }
    
    // Limpiar el punto de montaje antes de a√±adir un nuevo componente
    mountPoint.innerHTML = '';
    console.log('‚úÖ Punto de montaje encontrado y limpiado');
    
    // Cargar el componente web sin depender de refs
    await ExternalComponentLoader.loadComponent(customTypeId, version)
      .catch(async (err) => {
        console.warn(`Error al cargar componente con loader, intentando registro manual:`, err);
        // Registrar si no est√° registrado
        if (!ExternalComponentLoader.isRegistered(customTypeId)) {
          ExternalComponentLoader.registerComponent(componentConfig);
          return ExternalComponentLoader.loadComponent(customTypeId, version);
        }
        throw err;
      })
      .catch(async (err) => {
        console.warn(`Error despu√©s del registro manual, cargando script directamente:`, err);
        // Intentar cargar el script directamente como √∫ltimo recurso
        return new Promise<void>((resolve, reject) => {
          const script = document.createElement('script');
          script.src = componentConfig.cdnUrl;
          script.async = true;
          script.onload = () => {
            console.log(`‚úÖ Script cargado manualmente: ${componentConfig.cdnUrl}`);
            resolve();
          };
          script.onerror = (e) => reject(new Error(`Error al cargar script: ${e}`));
          document.head.appendChild(script);
        });
      });
      
    // Montar el componente usando el DOM API directamente
    console.log(`üîÑ Montando componente: ${componentConfig.metadata.tagName}`);
    
    // Verificar que el elemento custom est√© definido
    const customElementName = componentConfig.metadata.tagName;
    console.log(`üîç Verificando custom element: ${customElementName}`);
    console.log(`üîç customElements.get('${customElementName}'):`, customElements.get(customElementName));
    console.log(`üîç Lista de todos los custom elements definidos:`, 
                Object.getOwnPropertyNames(window).filter(name => name.includes('Element')));
    
    if (!customElements.get(customElementName)) {
      console.warn(`‚ö†Ô∏è Custom element '${customElementName}' no est√° registrado en customElements`);
      // Esperar un poco y reintentar
      await new Promise(resolve => setTimeout(resolve, 500));
      console.log(`üîç Segundo intento - customElements.get('${customElementName}'):`, customElements.get(customElementName));
      if (!customElements.get(customElementName)) {
        throw new Error(`Custom element '${customElementName}' no est√° disponible despu√©s del delay`);
      }
    }
    
    console.log(`‚úÖ Custom element '${customElementName}' est√° registrado`);
    
    // Crear elemento con manejo de errores
    let element;
    try {
      console.log(`üîÑ Intentando crear elemento: ${customElementName}`);
      element = document.createElement(customElementName);
      console.log(`‚úÖ Elemento '${customElementName}' creado exitosamente`);
      console.log(`üìä Tipo de elemento creado:`, typeof element, element.constructor.name);
    } catch (createError: any) {
      console.error(`‚ùå Error al crear elemento '${customElementName}':`, createError);
      throw new Error(`Error al crear el elemento: ${createError.message || createError}`);
    }
    
    componentInstance.value = element;
    
    // Configurar atributos de entrada
    element.setAttribute('session-id', sessionId);
    element.setAttribute('user-id', `user-${sessionId.split('-')[1]}`); // Generar user-id basado en session
    
    // Configurar objeto config
    const config = {
      theme: 'dark',
      showFooter: true,
      simulationMode: false, // Cambiar a false para que se vea igual que el acceso directo
      zoomLevel: props.zoomLevel || 1.0
    };
    element.setAttribute('config', JSON.stringify(config));
    
    // Configurar flow-context expandido
    const expandedFlowContext = {
      ...flowContext,
      currentStep: 1,
      totalSteps: 4,
      componentId: props.wizardStep?.componentData?.customTypeId,
      componentVersion: props.wizardStep?.componentData?.componentVersion || '1.0.0'
    };
    element.setAttribute('flow-context', JSON.stringify(expandedFlowContext));
    
    console.log('üîß Atributos configurados:');
    console.log('  - session-id:', sessionId);
    console.log('  - user-id:', `user-${sessionId.split('-')[1]}`);
    console.log('  - config:', JSON.stringify(config, null, 2));
    console.log('  - flow-context:', JSON.stringify(expandedFlowContext, null, 2));
    
    // A√±adir eventos
    element.addEventListener('component-ready', handleComponentReady);
    element.addEventListener('output-data', handleOutputData);
    element.addEventListener('request-navigation', handleNavigation);
    element.addEventListener('node-error', handleComponentError);
    console.log(`üéß Event listeners configurados para el componente`);
    
    // Obtener punto de montaje actualizado
    const finalMountPoint = document.getElementById('component-mount-point');
    if (!finalMountPoint) {
      throw new Error('Punto de montaje no disponible despu√©s de la preparaci√≥n');
    }
    
    // Montar componente
    finalMountPoint.appendChild(element);
    console.log(`‚úÖ Componente montado exitosamente en #component-mount-point`);
    
    loading.value = false;
  } catch (err: any) {
    console.error('Error al cargar componente externo:', err);
    error.value = err?.message || 'Error al cargar componente';
    loading.value = false;
    emit('error', error.value);
  }
}

// Handlers de eventos
function handleComponentReady(event: Event) {
  console.log('üéâ Componente externo listo:', event);
  console.log('üìã Detalles del evento component-ready:', (event as CustomEvent).detail);
  emit('ready', event);
}

function handleOutputData(event: any) {
  console.log('üì§ Datos de salida del componente:', event.detail);
  
  // Almacenar datos de salida
  outputData.value = { ...outputData.value, ...event.detail };
  
  // Extraer par√°metros espec√≠ficos si est√°n presentes
  const { horaInicio, horaFin, ...otherData } = event.detail || {};
  
  if (horaInicio) {
    console.log('‚è∞ Hora de inicio capturada:', horaInicio);
  }
  
  if (horaFin) {
    console.log('‚è∞ Hora de fin capturada:', horaFin);
  }
  
  if (Object.keys(otherData).length > 0) {
    console.log('üìã Otros datos capturados:', otherData);
  }
  
  // Crear objeto estructurado con todos los datos
  const structuredData = {
    sessionId,
    componentId: props.wizardStep?.componentData?.customTypeId,
    timestamp: new Date().toISOString(),
    outputParameters: {
      horaInicio,
      horaFin,
      ...otherData
    },
    allData: event.detail
  };
  
  console.log('üîÑ Avanzando al siguiente paso con datos estructurados:', structuredData);
  emit('next', structuredData);
}

function handleNavigation(event: any) {
  console.log('üß≠ Solicitud de navegaci√≥n:', event.detail);
  if (event.detail?.direction === 'previous') {
    console.log('‚¨ÖÔ∏è Navegando hacia atr√°s');
    emit('previous');
  }
}

function handleComponentError(event: any) {
  console.error('üö® Error en componente externo:', event.detail);
  error.value = event.detail?.message || 'Error en el componente';
  emit('error', error.value);
}

// Funci√≥n para obtener los datos de salida capturados
function getOutputData() {
  return outputData.value;
}

// Funci√≥n para obtener par√°metros espec√≠ficos
function getOutputParameter(key: string) {
  return outputData.value[key];
}

// Funci√≥n para limpiar los datos de salida
function clearOutputData() {
  outputData.value = {};
}

// Exponer funciones para uso externo
defineExpose({
  getOutputData,
  getOutputParameter,
  clearOutputData,
  componentInstance
});

// Lifecycle hooks
onMounted(() => {
  console.log('üîÑ ExternalComponentView montado, inicializando carga del componente');
  
  // Calcular altura inicial
  setTimeout(() => {
    calculateContainerHeight();
  }, 50);
  
  // Escuchar cambios de tama√±o de ventana
  window.addEventListener('resize', calculateContainerHeight);
  
  setTimeout(() => {
    // Ejecutar con un peque√±o delay para asegurar que el DOM est√° completamente renderizado
    loadExternalComponent();
  }, 100); // Un peque√±o delay para asegurar que el DOM est√° listo
});

onBeforeUnmount(() => {
  // Limpiar event listener de resize
  window.removeEventListener('resize', calculateContainerHeight);
  
  // Limpiar el componente y los eventos
  if (componentInstance.value) {
    componentInstance.value.removeEventListener('component-ready', handleComponentReady);
    componentInstance.value.removeEventListener('output-data', handleOutputData);
    componentInstance.value.removeEventListener('request-navigation', handleNavigation);
    componentInstance.value.removeEventListener('node-error', handleComponentError);
    
    // Limpiar del DOM si est√° montado
    const mountPoint = document.getElementById('component-mount-point');
    if (mountPoint?.contains(componentInstance.value)) {
      mountPoint.removeChild(componentInstance.value);
    }
  }
});

// Observar cambios en el paso del wizard
watch(() => props.wizardStep?.componentData, () => {
  if (componentInstance.value) {
    // Si cambia el paso y ya tenemos un componente instanciado, actualizarlo
    componentInstance.value.setAttribute('flow-context', JSON.stringify({
      ...flowContext,
      currentStep: props.wizardStep?.componentData?.customTypeId
    }));
  }
}, { deep: true });
</script>

<style scoped>
.external-component-container {
  display: flex;
  flex-direction: column;
  width: 100%;
  /* height ser√° calculada din√°micamente via JavaScript */
  min-height: 0; /* Permitir que se comprima */
  position: relative;
  border: 1px solid rgba(255, 255, 255, 0.1);
  border-radius: 8px;
  overflow: hidden; /* Sin scroll en el contenedor principal */
  background: #1e1e1e;
  /* Centrar el contenido */
  justify-content: center;
  align-items: center;
}

.loading-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  color: #fff;
}

.loading-spinner {
  width: 40px;
  height: 40px;
  border: 4px solid rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  border-top: 4px solid #4caf50;
  animation: spin 1s linear infinite;
  margin-bottom: 16px;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

.error-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100%;
  background-color: rgba(244, 67, 54, 0.1);
  color: #f44336;
  padding: 20px;
}

/* Aplicar zoom din√°mico al contenido del componente externo */
.component-mount-point {
  flex: 1;
  min-height: 0; /* Permitir que se comprima */
  overflow: hidden; /* Sin scroll en el punto de montaje */
  width: 100%;
  height: 100%;
  position: relative;
  /* Aplicar zoom solo al contenido del componente */
  transform: scale(var(--component-zoom, 1));
  transform-origin: center center;
  transition: transform 0.2s ease-in-out;
  /* Centrar el contenido para que se vea completo */
  display: flex;
  justify-content: center;
  align-items: center;
  flex-direction: column;
}

/* Dar dimensiones apropiadas al componente web */
.component-mount-point > * {
  width: 400px;  /* Ancho fijo para zoom √≥ptimo */
  height: 650px; /* Altura suficiente para mostrar todo el contenido */
  max-width: none; /* No limitar el tama√±o m√°ximo */
  max-height: none; /* No limitar el tama√±o m√°ximo */
  flex-shrink: 0; /* No permitir que se encoja */
}

.component-info {
  position: absolute;
  top: 8px;
  right: 8px;
  z-index: 10;
  background: rgba(0, 0, 0, 0.8);
  border-radius: 4px;
}

.component-tag {
  background-color: #333;
  color: #fff;
  padding: 4px 8px;
  border-radius: 4px;
  font-size: 11px;
  border: 1px solid rgba(255, 255, 255, 0.2);
}

/* Responsive para pantallas peque√±as  height: 100%;*/
@media (max-width: 900px) {
  .external-component-container {
    /* height ser√° calculada din√°micamente tambi√©n en m√≥viles */
    min-height: 300px !important;
  }
  
  .component-tag {
    font-size: 10px;
    padding: 2px 6px;
  }
}
</style>
