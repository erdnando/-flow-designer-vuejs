import { markRaw, defineComponent } from 'vue';

// Interfaces basadas en la documentaci√≥n t√©cnica
export interface ComponentConfig {
  id: string;
  name: string;
  version: string;
  cdnUrl: string;
  fallbackUrl?: string;
  type: 'web-component';
  contract: {
    inputs: string[];
    outputs: string[];
    events: string[];
  };
  metadata: {
    description: string;
    category: string;
    tagName: string;
  };
}

interface ComponentCache {
  component: any;
  loadedAt: Date;
  version: string;
}

/**
 * ExternalComponentLoader v2.0
 * 
 * Implementaci√≥n mejorada siguiendo las especificaciones de la documentaci√≥n t√©cnica.
 * Soporta Web Components con carga din√°mica, cache inteligente y fallbacks.
 */
export class ExternalComponentLoader {
  private static cache = new Map<string, ComponentCache>();
  private static loadingPromises = new Map<string, Promise<any>>();
  private static loadedScripts = new Set<string>();

  /**
   * Carga un componente externo y retorna wrapper Vue
   */
  static async loadComponent(config: ComponentConfig): Promise<any> {
    const cacheKey = `${config.id}@${config.version}`;
    
    // Verificar cache
    if (this.cache.has(cacheKey)) {
      const cached = this.cache.get(cacheKey)!;
      console.log(`‚úÖ Component ${config.id} loaded from cache`);
      return cached.component;
    }
    
    // Evitar cargas duplicadas
    if (this.loadingPromises.has(cacheKey)) {
      console.log(`‚è≥ Component ${config.id} already loading, waiting...`);
      return this.loadingPromises.get(cacheKey);
    }
    
    // Crear promesa de carga
    const loadPromise = this.loadComponentInternal(config);
    this.loadingPromises.set(cacheKey, loadPromise);
    
    try {
      const component = await loadPromise;
      
      // Guardar en cache
      this.cache.set(cacheKey, {
        component,
        loadedAt: new Date(),
        version: config.version
      });
      
      console.log(`‚úÖ Component ${config.id} v${config.version} loaded successfully`);
      return component;
      
    } catch (error) {
      console.error(`‚ùå Failed to load component ${config.id}:`, error);
      
      // Intentar fallback
      if (config.fallbackUrl && config.fallbackUrl !== config.cdnUrl) {
        console.log(`üîÑ Trying fallback for ${config.id}...`);
        const fallbackConfig = { ...config, cdnUrl: config.fallbackUrl };
        return this.loadComponentInternal(fallbackConfig);
      }
      
      // Retornar componente de error
      return this.createErrorComponent(config, error);
      
    } finally {
      this.loadingPromises.delete(cacheKey);
    }
  }

  /**
   * Carga interna del componente
   */
  private static async loadComponentInternal(config: ComponentConfig): Promise<any> {
    // Cargar script si no est√° cargado
    if (!this.loadedScripts.has(config.cdnUrl)) {
      await this.loadScript(config.cdnUrl);
      this.loadedScripts.add(config.cdnUrl);
      
      // Esperar a que el componente se registre
      await this.waitForCustomElement(config.metadata.tagName);
    }
    
    // Crear wrapper Vue para el Web Component
    return this.createVueWrapper(config);
  }

  /**
   * Carga script din√°micamente con timeout y retry
   */
  private static loadScript(url: string, timeout = 10000): Promise<void> {
    return new Promise((resolve, reject) => {
      // Verificar si ya existe
      const existingScript = document.querySelector(`script[src="${url}"]`);
      if (existingScript) {
        resolve();
        return;
      }
      
      const script = document.createElement('script');
      script.src = url;
      script.type = 'text/javascript';
      
      // Configurar headers para CORS
      script.crossOrigin = 'anonymous';
      
      // Timeout
      const timeoutId = setTimeout(() => {
        document.head.removeChild(script);
        reject(new Error(`Script load timeout: ${url}`));
      }, timeout);
      
      script.onload = () => {
        clearTimeout(timeoutId);
        console.log(`üì¶ Script loaded: ${url}`);
        resolve();
      };
      
      script.onerror = () => {
        clearTimeout(timeoutId);
        document.head.removeChild(script);
        reject(new Error(`Script load error: ${url}`));
      };
      
      document.head.appendChild(script);
    });
  }

  /**
   * Espera a que un Custom Element est√© disponible
   */
  private static waitForCustomElement(tagName: string, timeout = 5000): Promise<void> {
    return new Promise((resolve, reject) => {
      // Si ya est√° registrado
      if (customElements.get(tagName)) {
        resolve();
        return;
      }
      
      // Esperar a que se registre
      const timeoutId = setTimeout(() => {
        reject(new Error(`Custom element ${tagName} not registered within timeout`));
      }, timeout);
      
      customElements.whenDefined(tagName).then(() => {
        clearTimeout(timeoutId);
        console.log(`üéØ Custom element registered: ${tagName}`);
        resolve();
      });
    });
  }

  /**
   * Crea wrapper Vue para Web Component
   */
  private static createVueWrapper(config: ComponentConfig) {
    return markRaw(defineComponent({
      name: `${config.id}Wrapper`,
      props: {
        sessionId: String,
        userId: String,
        flowContext: Object,
        nodeData: Object,
        inputData: Object
      },
      emits: [
        'next',
        'previous', 
        'data-change',
        'error',
        'component-ready',
        'node-completed'
      ],
      template: `
        <div class="external-component-wrapper">
          <div class="component-container" ref="container"></div>
        </div>
      `,
      data() {
        return {
          componentElement: null as HTMLElement | null,
          isReady: false
        };
      },
      async mounted() {
        await this.initializeComponent();
      },
      beforeUnmount() {
        this.cleanupComponent();
      },
      watch: {
        // Observar cambios en props para actualizar el componente
        sessionId() { this.updateComponentProps(); },
        userId() { this.updateComponentProps(); },
        flowContext() { this.updateComponentProps(); },
        inputData() { this.updateComponentProps(); }
      },
      methods: {
        async initializeComponent() {
          try {
            // Crear elemento del Web Component
            const element = document.createElement(config.metadata.tagName);
            this.componentElement = element;
            
            // Configurar event listeners
            this.setupEventListeners(element);
            
            // Establecer props iniciales
            this.updateComponentProps();
            
            // Agregar al DOM
            (this.$refs as any).container.appendChild(element);
            
            console.log(`üé® Component wrapper initialized: ${config.id}`);
            
          } catch (error) {
            console.error(`‚ùå Error initializing component wrapper:`, error);
            this.$emit('error', (error as Error).message);
          }
        },
        
        setupEventListeners(element: HTMLElement) {
          // Event listeners est√°ndar seg√∫n documentaci√≥n t√©cnica
          
          element.addEventListener('component-ready', (e: any) => {
            this.isReady = true;
            this.$emit('component-ready', e.detail);
            console.log(`‚úÖ Component ready: ${config.id}`);
          });
          
          element.addEventListener('output-data', (e: any) => {
            this.$emit('next', e.detail);
          });
          
          element.addEventListener('node-completed', (e: any) => {
            this.$emit('node-completed', e.detail);
          });
          
          element.addEventListener('request-navigation', (e: any) => {
            if (e.detail.direction === 'previous') {
              this.$emit('previous', e.detail.data);
            }
          });
          
          element.addEventListener('data-changed', (e: any) => {
            this.$emit('data-change', e.detail);
          });
          
          element.addEventListener('node-error', (e: any) => {
            this.$emit('error', e.detail.error);
          });
        },
        
        // Establecer atributos del componente
          if (this.sessionId) {
            componentElement.setAttribute('session-id', this.sessionId);
          }
          
          if (this.userId) {
            componentElement.setAttribute('user-id', this.userId);
          }
          
          if (this.flowContext) {
            componentElement.setAttribute('flow-context', JSON.stringify(this.flowContext));
          }
          
          if (this.nodeData?.config) {
            componentElement.setAttribute('config', JSON.stringify(this.nodeData.config));
          }
          
          // M√©todo directo para input data
          if (this.inputData && typeof (componentElement as any).setInputData === 'function') {
            (componentElement as any).setInputData(this.inputData);
          }
        },
        
        cleanupComponent() {
          const componentElement = this.componentElement;
          if (componentElement) {
            // Remover todos los event listeners (se hace autom√°ticamente al remover del DOM)
            componentElement.remove();
            this.componentElement = null;
          }
        },
        
        // M√©todos p√∫blicos para interactuar con el componente
        getComponentData() {
          const componentElement = this.componentElement;
          if (componentElement && typeof (componentElement as any).getOutputData === 'function') {
            return (componentElement as any).getOutputData();
          }
          return null;
        },
        
        setComponentData(data: any) {
          const componentElement = this.componentElement;
          if (componentElement && typeof (componentElement as any).setInputData === 'function') {
            (componentElement as any).setInputData(data);
          }
        }
      }
    }));
        
        cleanupComponent() {
          const componentElement = (this as any).componentElement;
          if (componentElement) {
            // Remover todos los event listeners (se hace autom√°ticamente al remover del DOM)
            componentElement.remove();
            (this as any).componentElement = null;
          }
        },
        
        // M√©todos p√∫blicos para interactuar con el componente
        getComponentData() {
          const componentElement = (this as any).componentElement;
          if (componentElement && typeof componentElement.getOutputData === 'function') {
            return componentElement.getOutputData();
          }
          return null;
        },
        
        setComponentData(data: any) {
          const componentElement = (this as any).componentElement;
          if (componentElement && typeof componentElement.setInputData === 'function') {
            componentElement.setInputData(data);
          }
        }
      }
    });
  }

  /**
   * Crea componente de error como fallback
   */
  private static createErrorComponent(config: ComponentConfig, error: any) {
    return markRaw({
      name: 'ComponentError',
      props: ['onRetry'],
      template: `
        <div class="component-error">
          <div class="error-icon">‚ö†Ô∏è</div>
          <h3>Error cargando componente</h3>
          <p class="error-details">
            <strong>Componente:</strong> {{ config.name }} v{{ config.version }}<br>
            <strong>Error:</strong> {{ error.message }}
          </p>
          <div class="error-actions">
            <button @click="retry" class="retry-btn">üîÑ Reintentar</button>
            <button @click="skip" class="skip-btn">‚è≠Ô∏è Omitir</button>
          </div>
        </div>
      `,
      data() {
        return { config, error };
      },
      methods: {
        retry() {
          this.$emit('retry');
        },
        skip() {
          this.$emit('next', { skipped: true, reason: 'Component load error' });
        }
      },
      style: `
        .component-error {
          padding: 32px;
          text-align: center;
          background: #fff2f0;
          border: 1px solid #ffccc7;
          border-radius: 8px;
          color: #a8071a;
        }
        
        .error-icon {
          font-size: 48px;
          margin-bottom: 16px;
        }
        
        .error-details {
          margin: 16px 0;
          font-size: 14px;
          text-align: left;
          background: #fff;
          padding: 12px;
          border-radius: 4px;
          border: 1px solid #ffccc7;
        }
        
        .error-actions {
          display: flex;
          gap: 12px;
          justify-content: center;
          margin-top: 20px;
        }
        
        .retry-btn, .skip-btn {
          padding: 8px 16px;
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 500;
        }
        
        .retry-btn {
          background: #1890ff;
          color: white;
        }
        
        .skip-btn {
          background: #f5f5f5;
          color: #666;
        }
      `
    });
  }

  /**
   * Limpia cache y recursos
   */
  static clearCache(): void {
    this.cache.clear();
    this.loadingPromises.clear();
    console.log('üßπ Component cache cleared');
  }

  /**
   * Informaci√≥n del cache para debugging
   */
  static getCacheInfo() {
    return {
      cached: Array.from(this.cache.keys()),
      loading: Array.from(this.loadingPromises.keys()),
      scripts: Array.from(this.loadedScripts),
      stats: {
        cacheSize: this.cache.size,
        loadingComponents: this.loadingPromises.size,
        loadedScripts: this.loadedScripts.size
      }
    };
  }

  /**
   * Pre-carga componentes para mejor performance
   */
  static async preloadComponents(configs: ComponentConfig[]): Promise<void> {
    console.log(`üöÄ Preloading ${configs.length} components...`);
    
    const loadPromises = configs.map(config => 
      this.loadComponent(config).catch(error => {
        console.warn(`‚ö†Ô∏è Failed to preload ${config.id}:`, error);
        return null;
      })
    );
    
    await Promise.all(loadPromises);
    console.log('‚úÖ Component preloading completed');
  }
}
